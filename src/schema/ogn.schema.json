{
  "$ref": "#/definitions/OGN",
  "$schema": "http://json-schema.org/draft-07/schema#",
  "definitions": {
    "AnyType": {
      "const": "any",
      "type": "string"
    },
    "ArrayOfPrimitiveTupleType": {
      "enum": [
        "double[2][]",
        "double[3][]",
        "double[4][]",
        "float[2][]",
        "float[3][]",
        "float[4][]",
        "half[2][]",
        "half[3][]",
        "half[4][]",
        "int[2][]",
        "int[3][]",
        "int[4][]"
      ],
      "type": "string"
    },
    "ArrayValueRoleAttributeType": {
      "enum": [
        "colord[3][]",
        "colord[4][]",
        "colorf[3][]",
        "colorf[4][]",
        "colorh[3][]",
        "colorh[4][]",
        "matrixd[2][]",
        "matrixd[3][]",
        "matrixd[4][]",
        "normald[3][]",
        "normalf[3][]",
        "normalh[3][]",
        "vectord[3][]",
        "vectorf[3][]",
        "vectorh[3][]",
        "texcoordd[2][]",
        "texcoordd[3][]",
        "texcoordf[2][]",
        "texcoordf[3][]",
        "texcoordh[2][]",
        "texcoordh[3][]",
        "quatd[4][]",
        "quatf[4][]",
        "quath[4][]",
        "pointd[3][]",
        "pointf[3][]",
        "pointh[3][]",
        "frame[4][]",
        "objectId[]",
        "timecode[]"
      ],
      "type": "string"
    },
    "BundleType": {
      "const": "bundle",
      "type": "string"
    },
    "HEX": {
      "pattern": "^#[0-9a-fA-F]{8}$",
      "type": "string"
    },
    "IconType": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "additionalProperties": false,
          "properties": {
            "backgroundColor": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Vec4%3Cnumber%3E"
                },
                {
                  "$ref": "#/definitions/HEX"
                }
              ],
              "description": "a color representation for the part of the icon not containing its shape\n*"
            },
            "borderColor": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Vec4%3Cnumber%3E"
                },
                {
                  "$ref": "#/definitions/HEX"
                }
              ],
              "description": "a color representation for the outline of the icon"
            },
            "color": {
              "anyOf": [
                {
                  "$ref": "#/definitions/Vec4%3Cnumber%3E"
                },
                {
                  "$ref": "#/definitions/HEX"
                }
              ],
              "description": "a color representation for the draw part of the icon’s shape"
            },
            "path": {
              "description": "the icon location as with the simple syntax",
              "examples": [
                "icons/CompanyLogo.svg"
              ],
              "type": "string"
            }
          },
          "required": [
            "path",
            "color",
            "backgroundColor",
            "borderColor"
          ],
          "type": "object"
        }
      ]
    },
    "MemoryType": {
      "enum": [
        "cpu",
        "cuda",
        "any"
      ],
      "type": "string"
    },
    "NodeExclude": {
      "enum": [
        "c++",
        "docs",
        "icon",
        "python",
        "template",
        "tests",
        "usd"
      ],
      "type": "string"
    },
    "NodeInput": {
      "additionalProperties": false,
      "description": "The top level keyword of the attribute is always the unique name. It is always namespaced within the section it resides and only need be unique within that section. For example, the attribute mesh can appear in both the inputs and outputs sections, where it will be named inputs:mesh and outputs:mesh respectively.",
      "properties": {
        "default": {
          "description": "The default property on inputs contains the value of the attribute that will be used when the user has not explicitly set a value or provided an incoming connection to it. For outputs the default value is optional and will only be used when the node compute method cannot be run. The value type of the default property will be the JSON version of the type of data, shown in Attribute Data Types. https://docs.omniverse.nvidia.com/kit/docs/omni.graph.docs/latest/dev/ogn/ogn_reference_guide.html#ogn-keyword-attribute-default"
        },
        "deprecated": {
          "anyOf": [
            {
              "type": "string"
            },
            {
              "items": {
                "type": "string"
              },
              "type": "array"
            }
          ],
          "description": "The deprecated property is used to indicate that the attribute is being phased out and should no longer be used. The value of the property is a string or array of strings providing users with information on how they should change their graphs to accommodate the eventual removal of the attribute. https://docs.omniverse.nvidia.com/kit/docs/omni.graph.docs/latest/dev/ogn/ogn_reference_guide.html#ogn-keyword-attribute-deprecated"
        },
        "description": {
          "description": "As with the node, the description field is a multi-line description of the attribute, optionally with reStructuredText formatting. The description should contain enough information for the user to know how that attribute will be used (as an input), computed (as an output), or updated (as state).",
          "examples": [
            [
              "This node is part of the OmniGraph node writing examples."
            ]
          ],
          "type": "string"
        },
        "maximum": {
          "description": "When specified, these properties represent the minimum and maximum allowable value for the attribute. For arrays the values are applicable to every array element. For tuples the values will themselves be tuples with the same size.\n\nhttps://docs.omniverse.nvidia.com/kit/docs/omni.graph.docs/latest/dev/ogn/ogn_reference_guide.html#ogn-keyword-attribute-range"
        },
        "memoryType": {
          "$ref": "#/definitions/MemoryType",
          "description": "Node or attribute-level specification of the memory location",
          "title": "Memory Type"
        },
        "metadata": {
          "description": "Attributes can also have key/value style metadata attached to them by adding a dictionary of them using the metadata property. The key and value are any arbitrary string, though it’s a good idea to avoid keywords starting with underscore (_) as they may have special meaning to the graph. Lists of strings can also be used as metadata values, though they will be transformed into a single comma-separated string. https://docs.omniverse.nvidia.com/kit/docs/omni.graph.docs/latest/dev/ogn/ogn_reference_guide.html#ogn-keyword-attribute-metadata",
          "properties": {
            "allowMultiInputs": {
              "const": "1",
              "type": "string"
            },
            "allowedTokens": {
              "anyOf": [
                {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                {
                  "additionalProperties": {
                    "type": "string"
                  },
                  "type": "object"
                }
              ]
            },
            "hidden": {
              "const": "true",
              "type": "string"
            },
            "internal": {
              "const": "true",
              "type": "string"
            },
            "literalOnly": {
              "const": "1",
              "type": "string"
            },
            "outputOnly": {
              "const": "1",
              "type": "string"
            }
          },
          "type": "object"
        },
        "mininum": {
          "description": "When specified, these properties represent the minimum and maximum allowable value for the attribute. For arrays the values are applicable to every array element. For tuples the values will themselves be tuples with the same size.\n\nhttps://docs.omniverse.nvidia.com/kit/docs/omni.graph.docs/latest/dev/ogn/ogn_reference_guide.html#ogn-keyword-attribute-range"
        },
        "optional": {
          "description": "The optional property is used to tell the node whether the attribute’s value needs to be present in order for the compute function to run. If it is set to true then the value is not checked before calling compute. The default value false will not call the compute function if the attribute does not have a valid value. https://docs.omniverse.nvidia.com/kit/docs/omni.graph.docs/latest/dev/ogn/ogn_reference_guide.html#ogn-keyword-attribute-optional",
          "type": "boolean"
        },
        "type": {
          "anyOf": [
            {
              "$ref": "#/definitions/PrimitiveType"
            },
            {
              "$ref": "#/definitions/PrimitiveArrayType"
            },
            {
              "$ref": "#/definitions/PrimitiveTupleType"
            },
            {
              "$ref": "#/definitions/ArrayOfPrimitiveTupleType"
            },
            {
              "$ref": "#/definitions/ValueRoleAttributeType"
            },
            {
              "$ref": "#/definitions/ArrayValueRoleAttributeType"
            },
            {
              "$ref": "#/definitions/BundleType"
            },
            {
              "$ref": "#/definitions/TargetType"
            },
            {
              "$ref": "#/definitions/AnyType"
            },
            {
              "$ref": "#/definitions/UnionGroupType"
            },
            {
              "const": "token",
              "type": "string"
            },
            {
              "items": {
                "anyOf": [
                  {
                    "$ref": "#/definitions/PrimitiveType"
                  },
                  {
                    "$ref": "#/definitions/PrimitiveArrayType"
                  },
                  {
                    "$ref": "#/definitions/PrimitiveTupleType"
                  },
                  {
                    "$ref": "#/definitions/ArrayOfPrimitiveTupleType"
                  },
                  {
                    "$ref": "#/definitions/ValueRoleAttributeType"
                  },
                  {
                    "$ref": "#/definitions/ArrayValueRoleAttributeType"
                  },
                  {
                    "$ref": "#/definitions/BundleType"
                  },
                  {
                    "$ref": "#/definitions/TargetType"
                  },
                  {
                    "$ref": "#/definitions/AnyType"
                  },
                  {
                    "$ref": "#/definitions/UnionGroupType"
                  },
                  {
                    "const": "token",
                    "type": "string"
                  }
                ]
              },
              "type": "array"
            }
          ],
          "description": "The type property is one of several hard-coded values that specify what type of data the attribute contains. As we ramp up not all type combinations are supported; run generate_node.py –help to see the currently supported list of attribute types. For a full list of supported types and the data types they generate see Attribute Data Types.\nhttps://docs.omniverse.nvidia.com/kit/docs/omni.graph.docs/latest/dev/ogn/ogn_reference_guide.html#ogn-keyword-attribute-type",
          "examples": [
            [
              "string"
            ]
          ],
          "title": "Type",
          "uniqueItems": true
        },
        "uiName": {
          "description": "uiName is a very common piece of metadata, so as a shortcut it can also be specified as its own keyword at the attribute level. The meaning is the same; associate a piece of metadata with the attribute. This piece of metadata can be used by the UI to present a more human-readable name for the attribute. https://docs.omniverse.nvidia.com/kit/docs/omni.graph.docs/latest/dev/ogn/ogn_reference_guide.html#ogn-keyword-attribute-uiname",
          "type": "string"
        },
        "unvalidated": {
          "description": "unvalidated is similar to the optional keyword, in that it is used to tag attributes that may not take part in a compute(). The difference is that these attributes will always exists, they just may not have valid data when the compute is invoked. For such attributes the onus is on the node writer to check validity of such attributes if they do end up being used for the compute. https://docs.omniverse.nvidia.com/kit/docs/omni.graph.docs/latest/dev/ogn/ogn_reference_guide.html#ogn-keyword-attribute-unvalidated",
          "type": "boolean"
        }
      },
      "required": [
        "description",
        "type",
        "metadata"
      ],
      "type": "object"
    },
    "NodeLanguage": {
      "enum": [
        "c++",
        "python"
      ],
      "type": "string"
    },
    "NodeOutput": {
      "additionalProperties": false,
      "properties": {
        "description": {
          "type": "string"
        },
        "metadata": {
          "type": "object"
        },
        "type": {}
      },
      "required": [
        "type",
        "description",
        "metadata"
      ],
      "type": "object"
    },
    "NodeSchdedulingValue": {
      "enum": [
        "global",
        "global-read",
        "global-write",
        "static",
        "static-read",
        "static-write",
        "threadsafe",
        "topology",
        "topology-read",
        "topology-write",
        "usd",
        "usd-read",
        "usd-write",
        "compute-default",
        "compute-on-request",
        "pure"
      ],
      "type": "string"
    },
    "NodeScheduling": {
      "description": "NodeScheduling is a type that represents an array of NodeSchdedulingValue.",
      "examples": [
        [
          "global",
          "usd"
        ]
      ],
      "items": {
        "$ref": "#/definitions/NodeSchdedulingValue"
      },
      "title": "NodeScheduling",
      "type": "array"
    },
    "NodeState": {
      "properties": {
        "default": {
          "description": "Default value of the state."
        },
        "description": {
          "description": "A description of the state value.",
          "type": "string"
        },
        "type": {
          "description": "The type of the state value.",
          "type": "string"
        }
      },
      "required": [
        "type",
        "description",
        "default"
      ],
      "type": "object"
    },
    "NodeTest": {
      "type": "object"
    },
    "NumericValueRoleAttributeType": {
      "enum": [
        "colord[3]",
        "colord[4]",
        "colorf[3]",
        "colorf[4]",
        "colorh[3]",
        "colorh[4]",
        "matrixd[2]",
        "matrixd[3]",
        "matrixd[4]",
        "normald[3]",
        "normalf[3]",
        "normalh[3]",
        "vectord[3]",
        "vectorf[3]",
        "vectorh[3]",
        "texcoordd[2]",
        "texcoordd[3]",
        "texcoordf[2]",
        "texcoordf[3]",
        "texcoordh[2]",
        "texcoordh[3]",
        "quatd[4]",
        "quatf[4]",
        "quath[4]",
        "pointd[3]",
        "pointf[3]",
        "pointh[3]",
        "frame[4]"
      ],
      "type": "string"
    },
    "OGN": {
      "additionalProperties": {
        "additionalProperties": false,
        "properties": {
          "$comment": {
            "description": "JSON files do not have a syntax for adding comments, however in order to allow for adding descriptions or disabled values to a .ogn file the leading character “$” will treat the key in any key/value pair as a comment.",
            "examples": [
              [
                "This node is like a box of chocolates - you never know what you're gonna get"
              ]
            ],
            "title": "Comment",
            "type": "string"
          },
          "categories": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "string"
              },
              {
                "additionalProperties": {
                  "type": "string"
                },
                "type": "object"
              }
            ],
            "description": "Categories provide a way to group similar node types, mostly so that they can be managed easier in the UI.",
            "title": "NodeCategories"
          },
          "cudaPointers": {
            "description": "Usually when the memory type is set to cuda or any the CUDA memory pointers for array types are returned as a GPU pointer to GPU data, so when passing the data to CUDA code you have to pass pointers-to-pointers, since the CPU code cannot dereference them. Sometimes it is more efficient to just pass the GPU pointer directly though, pointed at by a CPU pointer. (It’s still a pointer to allow for null values.) You can do this by specifying “cpu” as your cudaPointers property. https://docs.omniverse.nvidia.com/kit/docs/omni.graph.docs/latest/dev/ogn/ogn_reference_guide.html#ogn-keyword-node-cudapointers",
            "enum": [
              "cuda",
              "cpu"
            ],
            "type": "string"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              }
            ],
            "description": "You can embed reStructuredText code in the string to be rendered in the final node documentation, though it will appear as-is in internal documentation such as Python docstrings.\nThe value can be a string or a list of strings. If it is a list, they will be concatenated as appropriate in the locations they are used. (Linefeeds preserved in Python docstrings, turned into a single space for text documentation, prepended with comment directives in code…)",
            "title": "NodeDescription"
          },
          "exclude": {
            "description": "Some node types will not be interested in all generated files, e.g. if the node is a Python node it will not need the C++ interface. Any of the generated files can be skipped by including it in a list of strings whose key is exclude. Here is a node which excludes all generated output, something you might do if you are developing the description of a new node and just want the node syntax to validate without generating code.\n\nLegal values to include in the exclusion list are “c++”, “docs”, “icon”, “python”, “template”, “tests”, or “usd”, in any combination.\nhttps://docs.omniverse.nvidia.com/kit/docs/omni.graph.docs/latest/dev/ogn/ogn_reference_guide.html#ogn-keyword-node-exclude",
            "items": {
              "$ref": "#/definitions/NodeExclude"
            },
            "title": "Exclude",
            "type": "array"
          },
          "icon": {
            "$ref": "#/definitions/IconType",
            "description": "Single string path or dictionary of detailed information to override icon appearance",
            "title": "NodeIcon"
          },
          "inputs": {
            "additionalProperties": {
              "$ref": "#/definitions/NodeInput"
            },
            "description": "Attributes that are read-only within the node’s compute function. These form the collection of data used to run the node’s computation algorithm.",
            "type": "object"
          },
          "language": {
            "$ref": "#/definitions/NodeLanguage",
            "description": "A string value that represents the language of implementation. The default when not specified is “c++”. The other legal value is “python”. This value indicates the language in which the node compute algorithm is written.",
            "title": "NodeLanguage"
          },
          "memoryType": {
            "$ref": "#/definitions/MemoryType",
            "description": "Node or attribute-level specification of the memory location",
            "title": "MemoryType"
          },
          "metadata": {
            "description": "Node types can have key/value style metadata attached to them by adding a dictionary of them using the metadata property. The key and value are any arbitrary string, though it’s a good idea to avoid keywords starting with with underscore (_) as they may have special meaning to the graph. Lists of strings can also be used as metadata values, though they will be transformed into a single comma-separated string. A simple example of useful metadata is a human readable format for your node type name. UI code can then read the consistently named metadata to provide a better name in any interface requiring node type selection. In the example the keyword author is used. There are several hardcoded metadata values, described in this guide. The keywords under which these are stored are available as constants for consistency, and can be found in Python in the og.MetadataKeys object and in C++ in the file omni/graph/core/ogn/Database.h. https://docs.omniverse.nvidia.com/kit/docs/omni.graph.docs/latest/dev/ogn/ogn_reference_guide.html#ogn-keyword-node-metadata",
            "properties": {
              "author": {
                "type": "string"
              }
            },
            "type": "object"
          },
          "outputs": {
            "additionalProperties": {
              "$ref": "#/definitions/NodeOutput"
            },
            "description": "Attributes whose values are generated as part of the computation algorithm. Until the node computes their values they will be undefined. This data is passed on to other nodes in the graph, or made available for inspection.",
            "type": "object"
          },
          "scheduling": {
            "$ref": "#/definitions/NodeScheduling",
            "description": "A string or list of string values that represent information for the scheduler on how nodes of this type may be safely scheduled. The string values are fixed, and say specific things about the kind of data the node access when computing.",
            "title": "Scheduling"
          },
          "singleton": {
            "description": "singleton is metadata with special meaning to the node type, so as a shortcut it can also be specified as its own keyword at the node level. The meaning is the same; associate a piece of metadata with the node type. This piece of metadata indicates the quality of the node type of only being able to instantiate a single node of that type in a graph or its child graphs. The value is specified as a boolean, though it is stored as the string “1”. (If the boolean is false then nothing is stored, as that is the default.) https://docs.omniverse.nvidia.com/kit/docs/omni.graph.docs/latest/dev/ogn/ogn_reference_guide.html#ogn-keyword-node-singleton",
            "type": "boolean"
          },
          "state": {
            "additionalProperties": {
              "$ref": "#/definitions/NodeState"
            },
            "description": "Attributes that persist between one evaluation and the next. They are both readable and writable. The primary difference between state attributes and output attributes is that when you set the value on a state attribute that value is guaranteed to be there the next time the node computes. Its data is entirely owned by the node.",
            "type": "object"
          },
          "tags": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              }
            ],
            "description": "tags is a very common piece of metadata, so as a shortcut it can also be specified as its own keyword at the node level. The meaning is the same; associate a piece of metadata with the node type. This piece of metadata can be used by the UI to better organize sets of nodes into common groups. https://docs.omniverse.nvidia.com/kit/docs/omni.graph.docs/latest/dev/ogn/ogn_reference_guide.html#ogn-keyword-node-tags",
            "examples": [
              "fruit,example,chocolate",
              [
                "fruit",
                "example",
                "chocolate"
              ],
              "fruit"
            ]
          },
          "tests": {
            "description": "Tests consist of a list of objects containing either direct values for input and output attributes, or a file path to an external test scene followed by a list of objects containing the expected output and state values to check for a user-specified node (as long as it exists in the test scene)",
            "items": {
              "$ref": "#/definitions/NodeTest"
            },
            "type": "array"
          },
          "tokens": {
            "$ref": "#/definitions/TokenType",
            "description": "Token types are more efficient than string types for comparison, and are fairly common. For that reason the .ogn file provides this shortcut to predefine some tokens for use in your node implementation code. https://docs.omniverse.nvidia.com/kit/docs/omni.graph.docs/latest/dev/ogn/ogn_reference_guide.html#ogn-keyword-node-tokens",
            "examples": [
              "apple",
              [
                "apple",
                "banana",
                "cherry"
              ]
            ]
          },
          "uiName": {
            "description": "uiName is a very common piece of metadata, so as a shortcut it can also be specified as its own keyword at the node level. The meaning is the same; associate a piece of metadata with the node type. This piece of metadata can be used by the UI to present a more human-readable name for the node type.",
            "examples": [
              "OmniGraph Example Node"
            ],
            "title": "UI Name",
            "type": "string"
          },
          "version": {
            "default": 1,
            "description": "The integer value version defines the version number of the current node definition. It is up to the node writer how to manage the encoding of version levels in the integer value. (For example a node might encode a major version of 3, a minor version of 6, and a patch version of 12 in two digit groups as the integer 30612, or it might simply use monotonic increasing values for versions 1, 2, 3…)",
            "minimum": 1,
            "title": "NodeVersion",
            "type": "integer"
          }
        },
        "required": [
          "description",
          "version",
          "language",
          "categories",
          "metadata",
          "uiName"
        ],
        "type": "object"
      },
      "type": "object"
    },
    "PrimitiveArrayType": {
      "enum": [
        "bool[]",
        "double[]",
        "float[]",
        "half[]",
        "int[]",
        "int64[]",
        "token[]",
        "uchar[]",
        "uint[]",
        "uint64[]"
      ],
      "type": "string"
    },
    "PrimitiveTupleType": {
      "enum": [
        "double[2]",
        "double[3]",
        "double[4]",
        "float[2]",
        "float[3]",
        "float[4]",
        "half[2]",
        "half[3]",
        "half[4]",
        "int[2]",
        "int[3]",
        "int[4]"
      ],
      "type": "string"
    },
    "PrimitiveType": {
      "enum": [
        "bool",
        "double",
        "int",
        "int64",
        "path",
        "uchar",
        "uint",
        "uint64",
        "token",
        "half",
        "float",
        "integer",
        "string"
      ],
      "type": "string"
    },
    "TargetType": {
      "const": "target",
      "type": "string"
    },
    "TokenType": {
      "anyOf": [
        {
          "type": "string"
        },
        {
          "items": {
            "type": "string"
          },
          "type": "array"
        },
        {
          "additionalProperties": {
            "type": "string"
          },
          "type": "object"
        }
      ]
    },
    "UnionGroupType": {
      "enum": [
        "integral_scalers",
        "integral_tuples",
        "integral_array_elements",
        "integral_arrays",
        "integrals",
        "matrices",
        "decimal_scalers",
        "decimal_tuples",
        "decimal_array_elements",
        "decimal_arrays",
        "decimals",
        "numeric_scalers",
        "numeric_tuples",
        "numeric_array_elements",
        "numeric_arrays",
        "numerics",
        "array_elements",
        "arrays",
        "strings"
      ],
      "type": "string"
    },
    "ValueRoleAttributeType": {
      "anyOf": [
        {
          "$ref": "#/definitions/NumericValueRoleAttributeType"
        },
        {
          "const": "execute",
          "type": "string"
        },
        {
          "const": "objectId",
          "type": "string"
        },
        {
          "const": "timecode",
          "type": "string"
        }
      ]
    },
    "Vec4<number>": {
      "items": {
        "type": "number"
      },
      "maxItems": 4,
      "minItems": 4,
      "type": "array"
    }
  }
}
